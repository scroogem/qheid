import pygame
import sys
import numpy as np
import math
import random
import time
from pygame import mixer

# Инициализация Pygame
pygame.init()
mixer.init()

# Константы
BLUE = (0, 0, 255)
BLACK = (0, 0, 0)
RED = (255, 0, 0)
YELLOW = (255, 255, 0)
WHITE = (255, 255, 255)
GREEN = (0, 255, 0)
PURPLE = (128, 0, 128)

ROW_COUNT = 6
COLUMN_COUNT = 7
SQUARESIZE = 100
RADIUS = int(SQUARESIZE/2 - 5)
WIN_LENGTH = 4

width = COLUMN_COUNT * SQUARESIZE
height = (ROW_COUNT + 1) * SQUARESIZE
size = (width, height)

screen = pygame.display.set_mode(size)
pygame.display.set_caption("Connect 4")
myfont = pygame.font.SysFont("monospace", 75)
smallfont = pygame.font.SysFont("monospace", 50)

class Game:
    def __init__(self):
        self.board = np.zeros((ROW_COUNT, COLUMN_COUNT))
        self.game_over = False
        self.turn = 0
        self.ai_mode = None
        self.player_names = ["Player 1", "Player 2"]
        self.scores = {"Player 1": 0, "Player 2": 0, "AI": 0}
        self.last_win_positions = []
    
    def reset(self):
        self.board = np.zeros((ROW_COUNT, COLUMN_COUNT))
        self.game_over = False
        self.last_win_positions = []
    
    def drop_piece(self, board, row, col, piece):
        board[row][col] = piece
    
    def is_valid_location(self, board, col):
        return board[ROW_COUNT-1][col] == 0
    
    def get_next_open_row(self, board, col):
        for r in range(ROW_COUNT):
            if board[r][col] == 0:
                return r
    
    def winning_move(self, board, piece):
        # Горизонтальные
        for c in range(COLUMN_COUNT - WIN_LENGTH + 1):
            for r in range(ROW_COUNT):
                win = True
                self.last_win_positions = []
                for i in range(WIN_LENGTH):
                    if board[r][c+i] != piece:
                        win = False
                        break
                    self.last_win_positions.append((r, c+i))
                if win:
                    return True

        # Вертикальные
        for c in range(COLUMN_COUNT):
            for r in range(ROW_COUNT - WIN_LENGTH + 1):
                win = True
                self.last_win_positions = []
                for i in range(WIN_LENGTH):
                    if board[r+i][c] != piece:
                        win = False
                        break
                    self.last_win_positions.append((r+i, c))
                if win:
                    return True

        # Диагонали (/)
        for c in range(COLUMN_COUNT - WIN_LENGTH + 1):
            for r in range(ROW_COUNT - WIN_LENGTH + 1):
                win = True
                self.last_win_positions = []
                for i in range(WIN_LENGTH):
                    if board[r+i][c+i] != piece:
                        win = False
                        break
                    self.last_win_positions.append((r+i, c+i))
                if win:
                    return True

        # Диагонали (\)
        for c in range(COLUMN_COUNT - WIN_LENGTH + 1):
            for r in range(WIN_LENGTH - 1, ROW_COUNT):
                win = True
                self.last_win_positions = []
                for i in range(WIN_LENGTH):
                    if board[r-i][c+i] != piece:
                        win = False
                        break
                    self.last_win_positions.append((r-i, c+i))
                if win:
                    return True
        return False
    
    def is_board_full(self, board):
        return all(board[ROW_COUNT-1][c] != 0 for c in range(COLUMN_COUNT))
    
    def ai_move_random(self, board):
        valid_locations = [c for c in range(COLUMN_COUNT) if self.is_valid_location(board, c)]
        return random.choice(valid_locations) if valid_locations else None
    
    def ai_move_smart(self, board, piece):
        # Проверка выигрышного хода
        for col in range(COLUMN_COUNT):
            if self.is_valid_location(board, col):
                row = self.get_next_open_row(board, col)
                temp_board = board.copy()
                self.drop_piece(temp_board, row, col, piece)
                if self.winning_move(temp_board, piece):
                    return col
        
        # Блокировка игрока
        opponent_piece = 1 if piece == 2 else 2
        for col in range(COLUMN_COUNT):
            if self.is_valid_location(board, col):
                row = self.get_next_open_row(board, col)
                temp_board = board.copy()
                self.drop_piece(temp_board, row, col, opponent_piece)
                if self.winning_move(temp_board, opponent_piece):
                    return col
        
        # Случайный ход
        return self.ai_move_random(board)
    
    def draw_board(self, board):
        for c in range(COLUMN_COUNT):
            for r in range(ROW_COUNT):
                pygame.draw.rect(screen, BLUE, (c*SQUARESIZE, r*SQUARESIZE+SQUARESIZE, SQUARESIZE, SQUARESIZE))
                pygame.draw.circle(screen, BLACK, (int(c*SQUARESIZE+SQUARESIZE/2), int(r*SQUARESIZE+SQUARESIZE+SQUARESIZE/2)), RADIUS)
        
        for c in range(COLUMN_COUNT):
            for r in range(ROW_COUNT):      
                if board[r][c] == 1:
                    pygame.draw.circle(screen, RED, (int(c*SQUARESIZE+SQUARESIZE/2), height-int(r*SQUARESIZE+SQUARESIZE/2)), RADIUS)
                elif board[r][c] == 2: 
                    pygame.draw.circle(screen, YELLOW, (int(c*SQUARESIZE+SQUARESIZE/2), height-int(r*SQUARESIZE+SQUARESIZE/2)), RADIUS)
        
        # Подсветка выигрышной комбинации
        for (r, c) in self.last_win_positions:
            pygame.draw.circle(screen, GREEN, (int(c*SQUARESIZE+SQUARESIZE/2), height-int(r*SQUARESIZE+SQUARESIZE/2)), RADIUS)
        
        pygame.display.update()
    
    def show_winner(self, winner):
        pygame.draw.rect(screen, BLACK, (0, 0, width, SQUARESIZE))
        
        if winner == 1:
            winner_name = self.player_names[0]
            color = RED
            self.scores[winner_name] = self.scores.get(winner_name, 0) + 1
        else:
            if self.ai_mode and self.turn == 1:
                winner_name = "AI"
                color = YELLOW
            else:
                winner_name = self.player_names[1]
                color = YELLOW
            self.scores[winner_name] = self.scores.get(winner_name, 0) + 1
        
        label = myfont.render(f"{winner_name} wins!", 1, color)
        screen.blit(label, (width/2 - label.get_width()/2, 10))
        pygame.display.update()
    
    def show_draw(self):
        pygame.draw.rect(screen, BLACK, (0, 0, width, SQUARESIZE))
        label = myfont.render("Game is a draw!", 1, WHITE)
        screen.blit(label, (width/2 - label.get_width()/2, 10))
        pygame.display.update()
    
    def show_turn(self, turn):
        pygame.draw.rect(screen, BLACK, (0, 0, width, SQUARESIZE))
        if turn == 0:
            text = smallfont.render(f"{self.player_names[0]}'s turn", 1, RED)
            pygame.draw.circle(screen, RED, (int(width/2), int(SQUARESIZE/2)), RADIUS)
        else:
            if self.ai_mode:
                text = smallfont.render("AI's turn", 1, YELLOW)
            else:
                text = smallfont.render(f"{self.player_names[1]}'s turn", 1, YELLOW)
            pygame.draw.circle(screen, YELLOW, (int(width/2), int(SQUARESIZE/2)), RADIUS)
        
        screen.blit(text, (width/2 - text.get_width()/2, 10))
        pygame.display.update()
    
    def animate_drop(self, board, col, piece):
        color = RED if piece == 1 else YELLOW
        row = self.get_next_open_row(board, col)
        
        for r in range(-1, row):
            pygame.draw.rect(screen, BLACK, (0, 0, width, SQUARESIZE))
            self.draw_board(board)
            
            posx = col * SQUARESIZE + SQUARESIZE/2
            posy = SQUARESIZE/2 if r == -1 else (r * SQUARESIZE + SQUARESIZE + SQUARESIZE/2)
            
            pygame.draw.circle(screen, color, (int(posx), int(posy)), RADIUS)
            pygame.display.update()
            pygame.time.wait(50)
    
    def show_menu(self):
        menu = True
        selected = 0
        options = [
            "1. Player vs Player",
            "2. Player vs AI (Easy)",
            "3. Player vs AI (Hard)",
            "4. Rules",
            "5. Scores",
            "6. Exit"
        ]
        
        while menu:
            screen.fill(BLACK)
            title = myfont.render("CONNECT 4", 1, WHITE)
            screen.blit(title, (width/2 - title.get_width()/2, 50))
            
            for i, option in enumerate(options):
                color = PURPLE if i == selected else WHITE
                text = smallfont.render(option, 1, color)
                screen.blit(text, (width/2 - text.get_width()/2, 150 + i*60))
            
            pygame.display.update()
            
            for event in pygame.event.get():
                if event.type == pygame.QUIT:
                    pygame.quit()
                    sys.exit()
                
                if event.type == pygame.KEYDOWN:
                    if event.key == pygame.K_DOWN:
                        selected = (selected + 1) % len(options)
                    elif event.key == pygame.K_UP:
                        selected = (selected - 1) % len(options)
                    elif event.key == pygame.K_RETURN:
                        if selected == 0:  # PvP
                            self.ai_mode = None
                            self.player_names = ["Player 1", "Player 2"]
                            return "start"
                        elif selected == 1:  # Easy AI
                            self.ai_mode = "easy"
                            self.player_names = ["Player", "AI"]
                            return "start"
                        elif selected == 2:  # Hard AI
                            self.ai_mode = "hard"
                            self.player_names = ["Player", "AI"]
                            return "start"
                        elif selected == 3:  # Rules
                            return "rules"
                        elif selected == 4:  # Scores
                            return "scores"
                        elif selected == 5:  # Exit
                            pygame.quit()
                            sys.exit()
                
                if event.type == pygame.MOUSEBUTTONDOWN:
                    pos = pygame.mouse.get_pos()
                    for i, option in enumerate(options):
                        text = smallfont.render(option, 1, WHITE)
                        text_rect = text.get_rect(center=(width/2, 150 + i*60))
                        if text_rect.collidepoint(pos):
                            if i == 0:  # PvP
                                self.ai_mode = None
                                self.player_names = ["Player 1", "Player 2"]
                                return "start"
                            elif i == 1:  # Easy AI
                                self.ai_mode = "easy"
                                self.player_names = ["Player", "AI"]
                                return "start"
                            elif i == 2:  # Hard AI
                                self.ai_mode = "hard"
                                self.player_names = ["Player", "AI"]
                                return "start"
                            elif i == 3:  # Rules
                                return "rules"
                            elif i == 4:  # Scores
                                return "scores"
                            elif i == 5:  # Exit
                                pygame.quit()
                                sys.exit()
    
    def show_rules(self):
        rules = [
            "Connect 4 Rules:",
            "",
            "1. Players take turns dropping pieces",
            f"2. First to connect {WIN_LENGTH} pieces wins",
            "3. Pieces can be connected:",
            "   - Horizontally",
            "   - Vertically",
            "   - Diagonally",
            "",
            "Click anywhere to return"
        ]
        
        waiting = True
        while waiting:
            screen.fill(BLACK)
            title = myfont.render("Game Rules", 1, WHITE)
            screen.blit(title, (width/2 - title.get_width()/2, 30))
            
            for i, line in enumerate(rules):
                text = smallfont.render(line, 1, WHITE)
                screen.blit(text, (width/2 - text.get_width()/2, 120 + i*40))
            
            pygame.display.update()
            
            for event in pygame.event.get():
                if event.type == pygame.QUIT:
                    pygame.quit()
                    sys.exit()
                if event.type == pygame.MOUSEBUTTONDOWN or event.type == pygame.KEYDOWN:
                    waiting = False
    
    def show_scores(self):
        waiting = True
        while waiting:
            screen.fill(BLACK)
            title = myfont.render("Scores", 1, WHITE)
            screen.blit(title, (width/2 - title.get_width()/2, 30))
            
            y_pos = 120
            for player, score in self.scores.items():
                text = smallfont.render(f"{player}: {score}", 1, WHITE)
                screen.blit(text, (width/2 - text.get_width()/2, y_pos))
                y_pos += 50
            
            text = smallfont.render("Click anywhere to return", 1, WHITE)
            screen.blit(text, (width/2 - text.get_width()/2, height - 50))
            
            pygame.display.update()
            
            for event in pygame.event.get():
                if event.type == pygame.QUIT:
                    pygame.quit()
                    sys.exit()
                if event.type == pygame.MOUSEBUTTONDOWN or event.type == pygame.KEYDOWN:
                    waiting = False
    
    def main_game_loop(self):
        self.reset()
        self.draw_board(self.board)
        self.show_turn(self.turn)
        
        while not self.game_over:
            for event in pygame.event.get():
                if event.type == pygame.QUIT:
                    pygame.quit()
                    sys.exit()
                
                if event.type == pygame.MOUSEMOTION:
                    pygame.draw.rect(screen, BLACK, (0, 0, width, SQUARESIZE))
                    posx = event.pos[0]
                    if self.turn == 0:
                        pygame.draw.circle(screen, RED, (posx, int(SQUARESIZE/2)), RADIUS)
                    else:
                        if not self.ai_mode:
                            pygame.draw.circle(screen, YELLOW, (posx, int(SQUARESIZE/2)), RADIUS)
                    self.show_turn(self.turn)
                    pygame.display.update()
                
                if event.type == pygame.MOUSEBUTTONDOWN and (self.turn == 0 or not self.ai_mode):
                    pygame.draw.rect(screen, BLACK, (0, 0, width, SQUARESIZE))
                    
                    posx = event.pos[0]
                    col = int(math.floor(posx/SQUARESIZE))
                    
                    if self.is_valid_location(self.board, col):
                        self.animate_drop(self.board, col, self.turn + 1)
                        row = self.get_next_open_row(self.board, col)
                        self.drop_piece(self.board, row, col, self.turn + 1)
                        
                        if self.winning_move(self.board, self.turn + 1):
                            self.draw_board(self.board)
                            self.show_winner(self.turn + 1)
                            self.game_over = True
                        elif self.is_board_full(self.board):
                            self.draw_board(self.board)
                            self.show_draw()
                            self.game_over = True
                        
                        self.turn += 1
                        self.turn = self.turn % 2
                        self.show_turn(self.turn)
            
            # Ход ИИ
            if self.ai_mode and self.turn == 1 and not self.game_over:
                pygame.time.wait(500)
                col = self.ai_move_random(self.board) if self.ai_mode == "easy" else self.ai_move_smart(self.board, 2)
                
                if col is not None and self.is_valid_location(self.board, col):
                    self.animate_drop(self.board, col, 2)
                    row = self.get_next_open_row(self.board, col)
                    self.drop_piece(self.board, row, col, 2)
                    
                    if self.winning_move(self.board, 2):
                        self.draw_board(self.board)
                        self.show_winner(2)
                        self.game_over = True
                    elif self.is_board_full(self.board):
                        self.draw_board(self.board)
                        self.show_draw()
                        self.game_over = True
                    
                    self.turn += 1
                    self.turn = self.turn % 2
                    self.show_turn(self.turn)
            
            if self.game_over:
                pygame.time.wait(3000)
                return

def main():
    game = Game()
    
    while True:
        action = game.show_menu()
        
        if action == "start":
            game.main_game_loop()
        elif action == "rules":
            game.show_rules()
        elif action == "scores":
            game.show_scores()

if __name__ == "__main__":
    main()








import random

ROWS = 6
COLUMNS = 7

def create_grid():
    return [[" " for _ in range(COLUMNS)] for _ in range(ROWS)]

def print_grid(grid):
    print(" " + " ".join(str(i) for i in range(COLUMNS)))
    for row in grid:
        print("|" + "|".join(row) + "|")
    print("-" * (COLUMNS * 2 + 1))

def drop_piece(grid, column, piece):
    for row in reversed(grid):
        if row[column] == " ":
            row[column] = piece
            return True
    return False

def is_winning_move(grid, piece):
    for row in range(ROWS):
        for col in range(COLUMNS - 3):
            if all(grid[row][col + i] == piece for i in range(4)):
                return True
    for row in range(ROWS - 3):
        for col in range(COLUMNS):
            if all(grid[row + i][col] == piece for i in range(4)):
                return True
    for row in range(ROWS - 3):
        for col in range(COLUMNS - 3):
            if all(grid[row + i][col + i] == piece for i in range(4)):
                return True
    for row in range(ROWS - 3):
        for col in range(3, COLUMNS):
            if all(grid[row + i][col - i] == piece for i in range(4)):
                return True
    return False

def is_draw(grid):
    return all(cell != " " for row in grid for cell in row)

def show_rules():
    print("""
RÈGLES DU JEU :
- Deux joueurs jouent à tour de rôle.
- À chaque tour, un joueur choisit une colonne.
- Le pion tombe à la première case vide de la colonne.
- Le but est d'aligner 4 pions (horizontalement, verticalement ou en diagonale).
- Si la grille est pleine sans gagnant, c’est un match nul.
""")

def get_valid_columns(grid):
    return [col for col in range(COLUMNS) if grid[0][col] == " "]

def player_vs_player():
    grid = create_grid()
    player_turn = 1
    print_grid(grid)

    while True:
        print(f"\nJoueur {player_turn}")
        try:
            column = int(input("Choisissez une colonne (0-6): "))
            if column < 0 or column >= COLUMNS:
                print("Colonne invalide.")
                continue
        except ValueError:
            print("Veuillez entrer un nombre.")
            continue

        piece = "X" if player_turn == 1 else "O"
        if drop_piece(grid, column, piece):
            print_grid(grid)
            if is_winning_move(grid, piece):
                print(f"Joueur {player_turn} a gagné!")
                break
            elif is_draw(grid):
                print("Match nul!")
                break
            player_turn = 2 if player_turn == 1 else 1
        else:
            print("Colonne pleine. Choisissez une autre.")

def player_vs_random_bot():
    grid = create_grid()
    print_grid(grid)
    player_turn = 1

    while True:
        if player_turn == 1:
            print("\nJoueur 1")
            try:
                column = int(input("Choisissez une colonne (0-6): "))
                if column < 0 or column >= COLUMNS:
                    print("Colonne invalide.")
                    continue
            except ValueError:
                print("Veuillez entrer un nombre.")
                continue
        else:
            column = random.choice(get_valid_columns(grid))
            print(f"\nBot choisit la colonne {column}")

        piece = "X" if player_turn == 1 else "O"
        if drop_piece(grid, column, piece):
            print_grid(grid)
            if is_winning_move(grid, piece):
                print("Joueur 1 a gagné!" if player_turn == 1 else "Le bot a gagné!")
                break
            elif is_draw(grid):
                print("Match nul!")
                break
            player_turn = 2 if player_turn == 1 else 1
        else:
            if player_turn == 1:
                print("Colonne pleine. Choisissez une autre.")

def bot_smart_move(grid, bot_piece, player_piece):
    valid_cols = get_valid_columns(grid)
    for col in valid_cols:
        temp_grid = [row[:] for row in grid]
        drop_piece(temp_grid, col, bot_piece)
        if is_winning_move(temp_grid, bot_piece):
            return col
    for col in valid_cols:
        temp_grid = [row[:] for row in grid]
        drop_piece(temp_grid, col, player_piece)
        if is_winning_move(temp_grid, player_piece):
            return col
    return random.choice(valid_cols)

def player_vs_smart_bot():
    grid = create_grid()
    print_grid(grid)
    player_turn = 1

    while True:
        if player_turn == 1:
            print("\nJoueur 1")
            try:
                column = int(input("Choisissez une colonne (0-6): "))
                if column < 0 or column >= COLUMNS:
                    print("Colonne invalide.")
                    continue
            except ValueError:
                print("Veuillez entrer un nombre.")
                continue
        else:
            column = bot_smart_move(grid, "O", "X")
            print(f"\nBot (intelligent) choisit la colonne {column}")

        piece = "X" if player_turn == 1 else "O"
        if drop_piece(grid, column, piece):
            print_grid(grid)
            if is_winning_move(grid, piece):
                print("Joueur 1 a gagné!" if player_turn == 1 else "Le bot intelligent a gagné!")
                break
            elif is_draw(grid):
                print("Match nul!")
                break
            player_turn = 2 if player_turn == 1 else 1
        else:
            if player_turn == 1:
                print("Colonne pleine. Choisissez une autre.")

def main_menu():
    while True:
        print("\n--- CONNECT 4 ---")
        print("1. 2 Joueurs")
        print("2. Contre un bot (aléatoire)")
        print("3. Contre un bot intelligent")
        print("4. Voir les règles")
        print("5. Quitter")
        choice = input("Choisissez une option: ")

        if choice == "1":
            player_vs_player()
        elif choice == "2":
            player_vs_random_bot()
        elif choice == "3":
            player_vs_smart_bot()
        elif choice == "4":
            show_rules()
        elif choice == "5":
            print("À bientôt !")
            break
        else:
            print("Option invalide.")

if __name__ == "__main__":
    main_menu()

















import os
import random
from itertools import cycle

class ConnectFour:
    def __init__(self, rows=6, cols=7):
        self.rows = rows
        self.cols = cols
        self.grid = [[' ' for _ in range(cols)] for _ in range(rows)]
        self.players = ['Joueur 1', 'Joueur 2']
        self.current_player = 0
        self.game_modes = {
            1: ('2 Joueurs', self.two_players_mode),
            2: ('VS AI (Facile)', self.ai_mode_random),
            3: ('VS AI (Expert)', self.ai_mode_smart)
        }
        self.symbols = ['X', 'O']
        self.scoreboard = {'Joueur 1': 0, 'Joueur 2': 0, 'AI': 0}

    def clear_screen(self):
        os.system('cls' if os.name == 'nt' else 'clear')

    def show_menu(self):
        while True:
            self.clear_screen()
            print("=== MENU PRINCIPAL ===")
            print("1. Nouvelle partie")
            print("2. Règles du jeu")
            print("3. Scores")
            print("4. Quitter")
            choice = input("Choix: ")

            if choice == '1':
                self.select_game_mode()
            elif choice == '2':
                self.show_rules()
            elif choice == '3':
                self.show_scores()
            elif choice == '4':
                exit()
            else:
                input("Choix invalide. Appuyez sur Entrée...")

    def show_scores(self):
        self.clear_screen()
        print("=== TABLEAU DES SCORES ===")
        for player, score in self.scoreboard.items():
            print(f"{player}: {score}")
        input("\nAppuyez sur Entrée pour continuer...")

    def select_game_mode(self):
        self.clear_screen()
        print("=== MODE DE JEU ===")
        for num, (name, _) in self.game_modes.items():
            print(f"{num}. {name}")
        choice = input("Choix: ")
        
        if choice in map(str, self.game_modes.keys()):
            self.setup_game(int(choice))
        else:
            input("Choix invalide. Appuyez sur Entrée...")

    def show_rules(self):
        self.clear_screen()
        print("=== RÈGLES DU JEU ===")
        print("Le but est d'aligner 4 pions de sa couleur")
        print("Horizontalement, verticalement ou en diagonale.")
        print("Choisissez une colonne (1-7) pour placer votre pion.")
        print("Le premier joueur à aligner 4 pions gagne !")
        input("\nAppuyez sur Entrée pour continuer...")

    def setup_game(self, mode):
        self.__init__()  # Réinitialiser le jeu
        if mode > 1:
            self.players[1] = 'AI'
        self.game_modes[mode][1]()

    def two_players_mode(self):
        self.play_game()

    def ai_mode_random(self):
        self.play_game(ai=True)

    def ai_mode_smart(self):
        self.play_game(ai=True, smart=True)

    def print_grid(self):
        self.clear_screen()
        for row in self.grid:
            print('|' + '|'.join(row) + '|')
        print('=' * (self.cols * 2 + 1))
        print(' ' + ' '.join(map(str, range(1, self.cols + 1))))

    def get_valid_moves(self):
        return [col for col in range(self.cols) if self.grid[0][col] == ' ']

    def drop_piece(self, col, symbol):
        for row in reversed(self.grid):
            if row[col] == ' ':
                row[col] = symbol
                return True
        return False

    def check_winner(self, symbol):
        # Vérification horizontale
        for row in self.grid:
            for i in range(self.cols - 3):
                if all(cell == symbol for cell in row[i:i+4]):
                    return True

        # Vérification verticale
        for col in range(self.cols):
            for i in range(self.rows - 3):
                if all(self.grid[i+j][col] == symbol for j in range(4)):
                    return True

        # Vérification diagonales
        for i in range(self.rows - 3):
            for j in range(self.cols - 3):
                if all(self.grid[i+k][j+k] == symbol for k in range(4)):
                    return True
                if all(self.grid[i+3-k][j+k] == symbol for k in range(4)):
                    return True
        return False

    def smart_ai_move(self, symbol):
        # Vérifie les victoires possibles
        for col in self.get_valid_moves():
            temp = [row.copy() for row in self.grid]
            self.drop_piece(col, symbol)
            if self.check_winner(symbol):
                self.grid = temp
                return col
            self.grid = temp

        # Vérifie les menaces adverses
        opponent = 'X' if symbol == 'O' else 'O'
        for col in self.get_valid_moves():
            temp = [row.copy() for row in self.grid]
            self.drop_piece(col, opponent)
            if self.check_winner(opponent):
                self.grid = temp
                return col
            self.grid = temp

        # Choix aléatoire sinon
        return random.choice(self.get_valid_moves())

    def play_game(self, ai=False, smart=False):
        while True:
            self.print_grid()
            print(f"Tour de : {self.players[self.current_player]}")

            if ai and self.current_player == 1:
                if smart:
                    col = self.smart_ai_move(self.symbols[self.current_player])
                else:
                    col = random.choice(self.get_valid_moves())
                print(f"L'AI choisit la colonne {col + 1}")
            else:
                try:
                    col = int(input("Colonne (1-7): ")) - 1
                    if col < 0 or col >= self.cols:
                        raise ValueError
                except ValueError:
                    input("Colonne invalide. Appuyez sur Entrée...")
                    continue

            if col not in self.get_valid_moves():
                input("Colonne pleine. Appuyez sur Entrée...")
                continue

            self.drop_piece(col, self.symbols[self.current_player])

            if self.check_winner(self.symbols[self.current_player]):
                self.print_grid()
                winner = self.players[self.current_player]
                print(f"{winner} gagne !")
                self.scoreboard[winner] += 1
                break

            if not self.get_valid_moves():
                self.print_grid()
                print("Match nul !")
                break

            self.current_player = 1 - self.current_player

        input("Appuyez sur Entrée pour revenir au menu...")
        self.show_menu()

if __name__ == "__main__":
    game = ConnectFour()
    game.show_menu()
















import pygame
import sys
import numpy as np
import math
import random
import time
from pygame import mixer

# Инициализация Pygame
pygame.init()
mixer.init()

# Константы
BLUE = (0, 0, 255)
BLACK = (0, 0, 0)
RED = (255, 0, 0)
YELLOW = (255, 255, 0)
WHITE = (255, 255, 255)
GREEN = (0, 255, 0)
PURPLE = (128, 0, 128)

ROW_COUNT = 6
COLUMN_COUNT = 7
SQUARESIZE = 100
RADIUS = int(SQUARESIZE/2 - 5)
WIN_LENGTH = 4  # Можно изменить на 5 для "5 в ряд"

width = COLUMN_COUNT * SQUARESIZE
height = (ROW_COUNT + 1) * SQUARESIZE
size = (width, height)

screen = pygame.display.set_mode(size)
pygame.display.set_caption("Connect 4")
myfont = pygame.font.SysFont("monospace", 75)
smallfont = pygame.font.SysFont("monospace", 50)

# Звуки
try:
    drop_sound = mixer.Sound('drop.wav')
    win_sound = mixer.Sound('win.wav')
    draw_sound = mixer.Sound('draw.wav')
except:
    print("Звуковые файлы не найдены, игра продолжится без звуков")

class Game:
    def __init__(self):
        self.board = np.zeros((ROW_COUNT, COLUMN_COUNT))
        self.game_over = False
        self.turn = 0
        self.ai_mode = None
        self.player_names = ["Player 1", "Player 2"]
        self.scores = {"Player 1": 0, "Player 2": 0, "AI": 0}
        self.last_win_positions = []
    
    def reset(self):
        self.board = np.zeros((ROW_COUNT, COLUMN_COUNT))
        self.game_over = False
        self.last_win_positions = []
    
    def create_board(self):
        return np.zeros((ROW_COUNT, COLUMN_COUNT))
    
    def drop_piece(self, board, row, col, piece):
        board[row][col] = piece
        try:
            drop_sound.play()
        except:
            pass
    
    def is_valid_location(self, board, col):
        return board[ROW_COUNT-1][col] == 0
    
    def get_next_open_row(self, board, col):
        for r in range(ROW_COUNT):
            if board[r][col] == 0:
                return r
    
    def print_board(self, board):
        print(np.flip(board, 0))
    
    def winning_move(self, board, piece):
        # Проверка горизонтальных линий
        for c in range(COLUMN_COUNT - WIN_LENGTH + 1):
            for r in range(ROW_COUNT):
                win = True
                self.last_win_positions = []
                for i in range(WIN_LENGTH):
                    if board[r][c+i] != piece:
                        win = False
                        break
                    self.last_win_positions.append((r, c+i))
                if win:
                    return True

        # Проверка вертикальных линий
        for c in range(COLUMN_COUNT):
            for r in range(ROW_COUNT - WIN_LENGTH + 1):
                win = True
                self.last_win_positions = []
                for i in range(WIN_LENGTH):
                    if board[r+i][c] != piece:
                        win = False
                        break
                    self.last_win_positions.append((r+i, c))
                if win:
                    return True

        # Проверка диагоналей (положительный наклон)
        for c in range(COLUMN_COUNT - WIN_LENGTH + 1):
            for r in range(ROW_COUNT - WIN_LENGTH + 1):
                win = True
                self.last_win_positions = []
                for i in range(WIN_LENGTH):
                    if board[r+i][c+i] != piece:
                        win = False
                        break
                    self.last_win_positions.append((r+i, c+i))
                if win:
                    return True

        # Проверка диагоналей (отрицательный наклон)
        for c in range(COLUMN_COUNT - WIN_LENGTH + 1):
            for r in range(WIN_LENGTH - 1, ROW_COUNT):
                win = True
                self.last_win_positions = []
                for i in range(WIN_LENGTH):
                    if board[r-i][c+i] != piece:
                        win = False
                        break
                    self.last_win_positions.append((r-i, c+i))
                if win:
                    return True
        return False
    
    def is_board_full(self, board):
        return all(board[ROW_COUNT-1][c] != 0 for c in range(COLUMN_COUNT))
    
    def ai_move_random(self, board):
        valid_locations = [c for c in range(COLUMN_COUNT) if self.is_valid_location(board, c)]
        return random.choice(valid_locations) if valid_locations else None
    
    def ai_move_smart(self, board, piece):
        # Проверка выигрышного хода
        for col in range(COLUMN_COUNT):
            if self.is_valid_location(board, col):
                row = self.get_next_open_row(board, col)
                temp_board = board.copy()
                self.drop_piece(temp_board, row, col, piece)
                if self.winning_move(temp_board, piece):
                    return col
        
        # Проверка выигрышного хода противника
        opponent_piece = 1 if piece == 2 else 2
        for col in range(COLUMN_COUNT):
            if self.is_valid_location(board, col):
                row = self.get_next_open_row(board, col)
                temp_board = board.copy()
                self.drop_piece(temp_board, row, col, opponent_piece)
                if self.winning_move(temp_board, opponent_piece):
                    return col
        
        # Если нет срочных ходов, выбираем случайный
        return self.ai_move_random(board)
    
    def draw_board(self, board):
        for c in range(COLUMN_COUNT):
            for r in range(ROW_COUNT):
                pygame.draw.rect(screen, BLUE, (c*SQUARESIZE, r*SQUARESIZE+SQUARESIZE, SQUARESIZE, SQUARESIZE))
                pygame.draw.circle(screen, BLACK, (int(c*SQUARESIZE+SQUARESIZE/2), int(r*SQUARESIZE+SQUARESIZE+SQUARESIZE/2)), RADIUS)
        
        for c in range(COLUMN_COUNT):
            for r in range(ROW_COUNT):      
                if board[r][c] == 1:
                    pygame.draw.circle(screen, RED, (int(c*SQUARESIZE+SQUARESIZE/2), height-int(r*SQUARESIZE+SQUARESIZE/2)), RADIUS)
                elif board[r][c] == 2: 
                    pygame.draw.circle(screen, YELLOW, (int(c*SQUARESIZE+SQUARESIZE/2), height-int(r*SQUARESIZE+SQUARESIZE/2)), RADIUS)
        
        # Подсветка выигрышной комбинации
        for (r, c) in self.last_win_positions:
            pygame.draw.circle(screen, GREEN, (int(c*SQUARESIZE+SQUARESIZE/2), height-int(r*SQUARESIZE+SQUARESIZE/2)), RADIUS)
        
        pygame.display.update()
    
    def show_winner(self, winner):
        pygame.draw.rect(screen, BLACK, (0, 0, width, SQUARESIZE))
        if winner == 1:
            label = myfont.render(f"{self.player_names[0]} wins!", 1, RED)
            self.scores[self.player_names[0]] += 1
        else:
            if self.ai_mode and winner == 2 and self.turn == 1:
                label = myfont.render("AI wins!", 1, YELLOW)
                self.scores["AI"] += 1
            else:
                label = myfont.render(f"{self.player_names[1]} wins!", 1, YELLOW)
                self.scores[self.player_names[1]] += 1
        
        try:
            win_sound.play()
        except:
            pass
        
        screen.blit(label, (40, 10))
        pygame.display.update()
    
    def show_draw(self):
        pygame.draw.rect(screen, BLACK, (0, 0, width, SQUARESIZE))
        label = myfont.render("Game is a draw!", 1, WHITE)
        
        try:
            draw_sound.play()
        except:
            pass
        
        screen.blit(label, (40, 10))
        pygame.display.update()
    
    def show_turn(self, turn):
        pygame.draw.rect(screen, BLACK, (0, 0, width, SQUARESIZE))
        if turn == 0:
            text = smallfont.render(f"{self.player_names[0]}'s turn", 1, RED)
            pygame.draw.circle(screen, RED, (int(width/2), int(SQUARESIZE/2)), RADIUS)
        else:
            if self.ai_mode and turn == 1:
                text = smallfont.render("AI's turn", 1, YELLOW)
            else:
                text = smallfont.render(f"{self.player_names[1]}'s turn", 1, YELLOW)
            pygame.draw.circle(screen, YELLOW, (int(width/2), int(SQUARESIZE/2)), RADIUS)
        
        screen.blit(text, (width/2 - text.get_width()/2, 10))
        pygame.display.update()
    
    def animate_drop(self, board, col, piece):
        color = RED if piece == 1 else YELLOW
        row = self.get_next_open_row(board, col)
        
        for r in range(-1, row):
            pygame.draw.rect(screen, BLACK, (0, 0, width, SQUARESIZE))
            self.draw_board(board)
            
            posx = col * SQUARESIZE + SQUARESIZE/2
            posy = SQUARESIZE/2 if r == -1 else (r * SQUARESIZE + SQUARESIZE + SQUARESIZE/2)
            
            pygame.draw.circle(screen, color, (int(posx), int(posy)), RADIUS)
            pygame.display.update()
            pygame.time.wait(50)
    
    def show_menu(self):
        menu = True
        selected = 0
        options = [
            "1. Player vs Player",
            "2. Player vs AI (Easy)",
            "3. Player vs AI (Hard)",
            "4. Rules",
            "5. Scores",
            "6. Exit"
        ]
        
        while menu:
            screen.fill(BLACK)
            title = myfont.render("CONNECT 4", 1, WHITE)
            screen.blit(title, (width/2 - title.get_width()/2, 50))
            
            for i, option in enumerate(options):
                color = PURPLE if i == selected else WHITE
                text = smallfont.render(option, 1, color)
                screen.blit(text, (width/2 - text.get_width()/2, 150 + i*60))
            
            pygame.display.update()
            
            for event in pygame.event.get():
                if event.type == pygame.QUIT:
                    pygame.quit()
                    sys.exit()
                
                if event.type == pygame.KEYDOWN:
                    if event.key == pygame.K_DOWN:
                        selected = (selected + 1) % len(options)
                    elif event.key == pygame.K_UP:
                        selected = (selected - 1) % len(options)
                    elif event.key == pygame.K_RETURN:
                        if selected == 0:  # PvP
                            self.ai_mode = None
                            self.player_names = ["Player 1", "Player 2"]
                            return "start"
                        elif selected == 1:  # Easy AI
                            self.ai_mode = "easy"
                            self.player_names = ["Player", "AI"]
                            return "start"
                        elif selected == 2:  # Hard AI
                            self.ai_mode = "hard"
                            self.player_names = ["Player", "AI"]
                            return "start"
                        elif selected == 3:  # Rules
                            return "rules"
                        elif selected == 4:  # Scores
                            return "scores"
                        elif selected == 5:  # Exit
                            pygame.quit()
                            sys.exit()
                
                if event.type == pygame.MOUSEBUTTONDOWN:
                    pos = pygame.mouse.get_pos()
                    for i, option in enumerate(options):
                        text = smallfont.render(option, 1, WHITE)
                        text_rect = text.get_rect(center=(width/2, 150 + i*60))
                        if text_rect.collidepoint(pos):
                            if i == 0:  # PvP
                                self.ai_mode = None
                                self.player_names = ["Player 1", "Player 2"]
                                return "start"
                            elif i == 1:  # Easy AI
                                self.ai_mode = "easy"
                                self.player_names = ["Player", "AI"]
                                return "start"
                            elif i == 2:  # Hard AI
                                self.ai_mode = "hard"
                                self.player_names = ["Player", "AI"]
                                return "start"
                            elif i == 3:  # Rules
                                return "rules"
                            elif i == 4:  # Scores
                                return "scores"
                            elif i == 5:  # Exit
                                pygame.quit()
                                sys.exit()
    
    def show_rules(self):
        rules = [
            "Connect 4 Rules:",
            "",
            "1. Players take turns dropping pieces",
            "2. First to connect 4 pieces wins",
            "3. Pieces can be connected:",
            "   - Horizontally",
            "   - Vertically",
            "   - Diagonally",
            "",
            "Click anywhere to return"
        ]
        
        waiting = True
        while waiting:
            screen.fill(BLACK)
            title = myfont.render("Game Rules", 1, WHITE)
            screen.blit(title, (width/2 - title.get_width()/2, 30))
            
            for i, line in enumerate(rules):
                text = smallfont.render(line, 1, WHITE)
                screen.blit(text, (width/2 - text.get_width()/2, 120 + i*40))
            
            pygame.display.update()
            
            for event in pygame.event.get():
                if event.type == pygame.QUIT:
                    pygame.quit()
                    sys.exit()
                if event.type == pygame.MOUSEBUTTONDOWN or event.type == pygame.KEYDOWN:
                    waiting = False
    
    def show_scores(self):
        waiting = True
        while waiting:
            screen.fill(BLACK)
            title = myfont.render("Scores", 1, WHITE)
            screen.blit(title, (width/2 - title.get_width()/2, 30))
            
            y_pos = 120
            for player, score in self.scores.items():
                text = smallfont.render(f"{player}: {score}", 1, WHITE)
                screen.blit(text, (width/2 - text.get_width()/2, y_pos))
                y_pos += 50
            
            text = smallfont.render("Click anywhere to return", 1, WHITE)
            screen.blit(text, (width/2 - text.get_width()/2, height - 50))
            
            pygame.display.update()
            
            for event in pygame.event.get():
                if event.type == pygame.QUIT:
                    pygame.quit()
                    sys.exit()
                if event.type == pygame.MOUSEBUTTONDOWN or event.type == pygame.KEYDOWN:
                    waiting = False
    
    def main_game_loop(self):
        self.reset()
        self.draw_board(self.board)
        self.show_turn(self.turn)
        
        while not self.game_over:
            for event in pygame.event.get():
                if event.type == pygame.QUIT:
                    pygame.quit()
                    sys.exit()
                
                if event.type == pygame.MOUSEMOTION:
                    pygame.draw.rect(screen, BLACK, (0, 0, width, SQUARESIZE))
                    posx = event.pos[0]
                    if self.turn == 0:
                        pygame.draw.circle(screen, RED, (posx, int(SQUARESIZE/2)), RADIUS)
                    else:
                        if not self.ai_mode:
                            pygame.draw.circle(screen, YELLOW, (posx, int(SQUARESIZE/2)), RADIUS)
                    self.show_turn(self.turn)
                    pygame.display.update()
                
                if event.type == pygame.MOUSEBUTTONDOWN and (self.turn == 0 or not self.ai_mode):
                    pygame.draw.rect(screen, BLACK, (0, 0, width, SQUARESIZE))
                    
                    posx = event.pos[0]
                    col = int(math.floor(posx/SQUARESIZE))
                    
                    if self.is_valid_location(self.board, col):
                        self.animate_drop(self.board, col, self.turn + 1)
                        row = self.get_next_open_row(self.board, col)
                        self.drop_piece(self.board, row, col, self.turn + 1)
                        
                        if self.winning_move(self.board, self.turn + 1):
                            self.draw_board(self.board)
                            self.show_winner(self.turn + 1)
                            self.game_over = True
                        elif self.is_board_full(self.board):
                            self.draw_board(self.board)
                            self.show_draw()
                            self.game_over = True
                        
                        self.print_board(self.board)
                        self.draw_board(self.board)
                        
                        self.turn += 1
                        self.turn = self.turn % 2
                        self.show_turn(self.turn)
            
            # Ход ИИ
            if self.ai_mode and self.turn == 1 and not self.game_over:
                pygame.time.wait(500)  # Задержка для "обдумывания"
                col = self.ai_move_random(self.board) if self.ai_mode == "easy" else self.ai_move_smart(self.board, 2)
                
                if col is not None and self.is_valid_location(self.board, col):
                    self.animate_drop(self.board, col, 2)
                    row = self.get_next_open_row(self.board, col)
                    self.drop_piece(self.board, row, col, 2)
                    
                    if self.winning_move(self.board, 2):
                        self.draw_board(self.board)
                        self.show_winner(2)
                        self.game_over = True
                    elif self.is_board_full(self.board):
                        self.draw_board(self.board)
                        self.show_draw()
                        self.game_over = True
                    
                    self.print_board(self.board)
                    self.draw_board(self.board)
                    
                    self.turn += 1
                    self.turn = self.turn % 2
                    self.show_turn(self.turn)
            
            if self.game_over:
                pygame.time.wait(3000)
                return

def main():
    game = Game()
    
    while True:
        action = game.show_menu()
        
        if action == "start":
            game.main_game_loop()
        elif action == "rules":
            game.show_rules()
        elif action == "scores":
            game.show_scores()

if __name__ == "__main__":
    main()
